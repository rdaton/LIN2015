open
	lock(mtx)
	consumidor

		...

		lock(mtx)
		while(numero_productor <=0){
			cond_wait(consumidor,mtx);
		}

<<<<<<< HEAD
		cond_signal(productores)

	productor 
		...

=======
		cond_signal(consumidores)
		
	productor 
		...

		
>>>>>>> 0e34dd69c6053c5fe856f3e2e274c43033fe64c0
		while(numero_consumidor <=0){
			cond_wait(productor,mtx);
		}

		cond_signal(consumidores)
	unlock(mtx)


//111111111111111111111111111111111111111111111111111111111111

int prod_count=0,cons_count=0; cbuffer_t* cbuffer; 

int fifoproc_write(char* buff, int len) 
{
 char kbuffer[MAX_KBUF]; 
 if (len> MAX_CBUFFER_LEN || len> MAX_KBUF) 
 {
  return Error;} 

  if (copy_from_user(kbuffer,buff,len)) 
  {
   return Error;
	} 
   lock(mtx); 

   /* Esperar hasta que haya hueco para insertar (debe haber consumidores) */ 
   while (nr_gaps_cbuffer_t(cbuffer)<len && cons_count>0)
   { 
   	cond_wait(prod,mtx); 
   } 
   /* Detectar fin de comunicaciÃ³n por error (consumidor cierra FIFO antes) */ 
   
   if (cons_count==0) {unlock(mtx); return -EPIPE;} 
   insert_items_cbuffer_t(cbuffer,kbuffer,len); 
   
   /* Despertar a posible consumidor bloqueado */ 
   cond_signal(cons); 
   
   unlock(mtx); 
   return len; 

//11111111111111111111111111111111111111111111111111111111111


 int fifoproc_read(char* buff, int len)

 	char kbuffer[MAX_KBUF]; 
 if (len> MAX_CBUFFER_LEN || len> MAX_KBUF) 
 	{
  		return Error;
  	} 

 	if (copy_to_user(kbuffer,buff,len)) 
  	{
   		return Error;
	} 

<<<<<<< HEAD
=======
 	if( productor_count == 0 && size_cbuffer_t(cbuffer)==0){
 		return 0;
 	}
>>>>>>> 0e34dd69c6053c5fe856f3e2e274c43033fe64c0



 	lock(mtx); 
 	
 	/* Esperar hasta que haya elemento para sacar (debe haber cproductores) */ 
 	while (size_cbuffer_t(cbuffer)==0 && productor_count>0)
 		{ cond_wait(consumidor,mtx); } 
 
 	if( productor_count == 0 && size_cbuffer_t(cbuffer)==0){

 		return 0;
 	}


 	/* Obtener el primer elemento del buffer y eliminarlo */
  	item=head_cbuffer_t(cbuf);
  	remove_items_cbuffer_t ( cbuffer_t* cbuffer, char* items, int nr_items)



 	/* Despertar a posible productor bloqueado */ 
 	cond_signal(prod_count); 
 	unlock(mtx); 

 	return len;


//11111111111111111111111111111111111111111111111111111111111

release(struct inode *inodo, struct file *file)
	//entra sesion critica
<<<<<<< HEAD
	lock()
	if(consumidor)
	{
		consumidor--
		cond_signal(cons)	 
=======
	lock(mtx)
	if(consumidor)
	{
		
		consumidor--
	  	cond_signal
	 
>>>>>>> 0e34dd69c6053c5fe856f3e2e274c43033fe64c0
	  		
	}
	
	if(productor)
	{
		productor--
<<<<<<< HEAD
		cond_signal(prod)
=======
		cond_signal
>>>>>>> 0e34dd69c6053c5fe856f3e2e274c43033fe64c0
	}

	if (cons_count==0 && prod_count==0) 
	  		{
<<<<<<< HEAD
	  			clear_cbuffer_t (cbuffer_t* cbuffer); 

=======
	  			
	  			clear_cbuffer_t (cbuffer_t* cbuffer); 
	  			
	  			return 0;
>>>>>>> 0e34dd69c6053c5fe856f3e2e274c43033fe64c0
	  		} 
	   unlock(mtx);

	unlock(&mtx); 
	return 0;

}




















